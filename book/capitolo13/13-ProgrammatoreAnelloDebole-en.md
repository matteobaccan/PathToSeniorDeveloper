# What if the weak link in programming is the programmer themself?

While artificial intelligence promises to revolutionize software development by accelerating every phase of the process, a disturbing paradox emerges: the programmer themself may have become the main obstacle to the speed the market demands. In an ecosystem where automation generates code at unimaginable rates, human supervision introduces latencies, checks, and slowdowns that contradict the primary goal of efficiency.

## A bit of history

Let's try to understand the world of programming by reflecting on the normal evolution of a project and thinking about how a programmer moves over time.

When we take our first steps in this world, we begin to study the first languages and learn about the first components, libraries, and frameworks that can help us in our work.
The study of best practices and an increasingly deep knowledge of the tools used tend to focus our work on a known path that we tend to replicate, in part or in whole, in every new project.

If we reflect on programming, it is often a linear process: today we create a functional data entry, tomorrow we implement efficient controls, then we think about data abstraction mechanisms, create APIs, optimize performance, increase security measures, and so on.
Each project becomes the sum of previous experiences, appropriately reorganized: perhaps it's better to design the APIs from the start, security would be better implemented as a first step, let's use a consolidated control library, this authentication service, and so on. However, the sum of experiences, in a perspective of continuous evolution, can hide an insidious trap.

## The growing weight of complexity

The real problem lies not in the code itself, but in the complexity that inexorably accumulates over time. Each new project represents a starting point that is rarely truly new: the programmer immediately inserts everything they have learned in previous years, unconsciously accumulating layers of- complexity.

Initially, this complexity appears manageable, but it progressively turns into an increasingly difficult burden to bear. Each new feature, each bug to be fixed, each client request adds another layer that settles on the existing code, creating a stratification that requires increasingly specialized skills to be managed.

This dynamic clashes head-on with the expectations of the current market, where speed has become the dominant parameter. Customers want everything and they want it now:

```text
Create a website like Apple's, but in a week since you have everything ready.
The prototype must be ready by tonight.
The bug must be fixed by today.
```

and to finish with a quote that I must have heard an infinite number of times:

```text
When do you want this feature?
For yesterday!
```

The time pressure, always present, becomes increasingly constant and inescapable.

## The illusion of time compression

Faced with this pressure, the industry has tried various automation strategies. In the past, there were CASE (Computer-Aided Software Engineering) tools, code factories specialized for specific categories of problems. With the evolution of needs, these tools have transformed into modern frameworks: more flexible and general-purpose compared to the verticality of CASE, but still complex and not always intuitive to use.

The arrival of artificial intelligence has represented the ultimate promise: programs that write code for us, that solve problems automatically, that save time and effort. However, this apparent solution clashes with an inescapable reality: the programmer remains the controller of this process: a human controller, with all their limitations and reaction times.

Even by delegating the writing of the code to the AI, irreducible times persist: learning, adaptation, debugging, testing, and human supervision. As long as this supervision remains necessary, the overall time cannot be drastically reduced. It is precisely in this dynamic that the programmer emerges as a potential weak link: the human element that introduces overhead and latencies into the automation process.

## But how are AIs helping us and evolving?

2025 was the year of "vibe coding": programming assisted by artificial intelligence where each problem is solved through iterative prompts. If something doesn't work, a new prompt is generated; if something needs to be modified, yet another prompt.

This evolution has transformed AI from a simple support tool to the main work tool.

I have been working in "Vibe" mode for months, first with prompts entered in the various LLMs, then through Copilot, then with CLI tools like Gemini and Copilot Agent, up to more immersive tools.

After banging your head against it for a while, you start to see its limits and inconsistencies, although you often think they are more yours than the machine's you are using.

Like me, other prominent figures, such as Jack Dorsey, have begun to use AI for their "weekend projects," creating applications like BitChat entirely through automatically generated code.

However, direct experience with these tools reveals a complex dynamic. Relying completely on the "vibe" to generate large portions of code produces a high number of elements to be re-checked and fixed. The interpretative ability of the AI, although impressive, can easily deviate from the intended direction.

The most effective approach has proven to be that of fragmentation: using the AI for small specific tasks, checking and testing each component, and then assembling them manually. This method allows for quality control while still taking advantage of the acceleration offered by automation. It is analogous to the process of domestication: it is necessary to know, understand, and guide the tool before it can be used effectively.

## When the programmer stops: a near future scenario

The- growing acceleration of development processes raises a critical question: what happens when the programmer is not available? In the past, the absence of a developer simply meant a proportional slowdown. Release cycles were annual, the pressure for new features limited.

In the present, acceleration has transformed every interruption into a potential systemic problem. In the near future (2-3 years), it is plausible that projects will continue to evolve in an unsupervised manner during the programmer's absence, with the AI autonomously generating code, resolving issues, and managing branches.

Upon their return, the programmer would be faced with dozens of branches to examine, issues to understand, bugs to analyze to verify the correctness of the automatically generated code. The mental load of this situation is significant: a sense of guilt for the absence, anxiety from missed supervision, pressure to regain control of a process that has continued to evolve autonomously.

This scenario can easily degenerate into a vicious cycle of burnout, leaving the company, or loss of professional interest, summarized in the dangerous attitude:

```text
"Let's accept this pull request, the AI has already done all the work, what could go wrong?"
```

## The future of the programmer: beyond the immediate present

Projecting ourselves a few years into the future, the evolution of the programmer's role appears inevitable. AI already surpasses any typist in speed, is beginning to produce code of higher quality than that of many developers, and can make mistakes at an unprecedented speed. However, it remains pure power without strategic thinking.

The transformation of the programmer's role will likely follow this trajectory: less time dedicated to writing code directly, more time interacting with AIs and in business-oriented work. This change will require awareness and adequate preparation, as it will completely overturn the current conception of programming, pushing professionals beyond their current skills.

In this new paradigm, a person will describe a problem in a few sentences and a language model specialized in analysis will generate the prompts for a model specialized in writing the code. The programmer will evolve from a manual coder to a guide, tester, and, perhaps, a refiner of the code generated by the AI.

This transformation will entail the disappearance of some current practices: traditional debugging, the need to meticulously document the code, the importance of variables with explicit names. In parallel, new programming languages designed for interpretation by machines rather than for human readability will likely emerge.

## The human mind: the insurmountable limit

In this scenario of continuous acceleration, driven efficiency, and frenzied automation, there is one element that cannot be compressed: the human mind. Shaped by millions of years of evolution, our mind has developed mechanisms to solve complex problems through slow and thoughtful processes.

Depriving this "biological machine" of the time needed to process information and overloading it with continuous inputs produces only one result: a functional block. In a world where every slowdown generates disastrous domino effects, taking sick days or rest days risks becoming an inaccessible luxury.

In inadequately structured organizations, where each person is individually responsible for specific activities without adequate distribution of workloads, the mental and physical burden that each programmer must bear will become progressively unsustainable.

## Conclusions: the weak link that can break the chain

Programming is undergoing an epochal transformation with the advent of AI. We must learn to live with these technologies while preserving our humanity and critical thinking skills. The speed required by the market is not always sustainable, and sometimes it is preferable to slow down to ensure the quality of the work.

However, this choice exposes us to the risk of being perceived as the weak link in the production chain, the element that prevents time compression and the achievement of immediate results. Faced with this prospect, we will have to question the necessity and usefulness of our role, or whether we have become a burden to the organization.

I conclude with a reflection by Stanisław Jerzy Lec that I consider particularly significant:

```text
"The weakest link in the chain is also the strongest because it can break it."
```

The programmer, while being considered the weak link in the automation process, also holds the key to breaking the chains of complexity and speed imposed by the system.

Our strength lies in our ability to adapt, learn, and evolve. Although the future may label us as the weak link in the chain, our task is to transform this apparent weakness into the strong point of our work and our organizations, otherwise we will soon become obsolete and replaceable by increasingly intelligent and autonomous machines.
