# El mundo de la programación ha cambiado y con él la manera de convertirse en programador

Aún recuerdo el momento en que decidí convertirme en programador: era 1985, las radios sonaban "The Wild Boys" de Duran Duran y tenía que tomar una decisión importante: "¿Computadora o ciclomotor?".

A los 14 años es una elección difícil: por un lado podrías realizar lo que en tu cabeza es la evolución natural de un chico al que le gustan las matemáticas, es decir entender qué es la informática y hacer lo que películas como War Games pintaban como algo al alcance de cualquier niño; por otro lado, comprar un ciclomotor, acelerar libre por las calles, poder ir donde quieras y mostrarte a las chicas fuera del estereotipo del nerd.

Una elección difícil, agonizante, pensada durante meses, pero enfrentada como todas las mejores decisiones de mi vida: instintivamente, de manera completamente aleatoria.

Ganó la computadora.

Después de meses de espera, cuando logré convencer también a mis padres de que era una elección imprescindible, arrastré a mi padre a comprarla.

Mi padre conocía a alguien que tenía una "tienda Olivetti", lo que en los años 80 significaba estar en el centro del mundo informático, y la primera propuesta fue un "Olivetti Prodest".

Era joven, completamente ignorante sobre lo que significaba programar, pero estaba seguro de una cosa: el Prodest era la elección equivocada. Todos tenían el Commodore64, ¿era posible que yo debiera tener un Prodest?

También aquí, varios días para convencer a todos de que el Prodest no tenía futuro. "El Commodore sí lo tenía, era la computadora del futuro".

Con la perspectiva del tiempo entiendo cuán infundada era esta afirmación, no tenía ningún dato que la respaldara, excepto la publicidad martillante de ese período.

No recuerdo el día de la compra, solo recuerdo mi alegría al armarlo: se trataba de conectar la corriente y un monitor, que en realidad era una vieja TV en blanco y negro.

El primer día estaba devastado: me habían regalado un juego y había pasado toda la tarde jugando.

Pensé que dormiría bien, pero esa noche no pude cerrar los ojos, una mezcla de alegría, euforia y decepción. A esa edad siempre tienes más dudas que certezas: ¿por qué había perdido la tarde jugando, cuando en cambio quería ser "el programador"? Después de todo, ni siquiera sabía qué significaba, pero estaba seguro de que no se trataba de jugar, sino de algo diferente.

En los días siguientes leí varias veces el manual: un cuaderno de anillas, en formato A5, con la cubierta a rayas y el logo de Commodore. Creo que aún recuerdo el olor del papel, pero tal vez sea solo una ilusión de la memoria.

Desde allí comenzaron años de errores, intentos, presuntos éxitos y fracasos.

De lenguaje a lenguaje, de computadora a computadora, de sistema operativo a sistema operativo, de librería a librería, de framework a framework.

Un viaje que duró décadas, donde cada día aprendí algo nuevo, donde cada día entendí que nunca se deja de aprender.

Pero ese es el pasado, un pasado romántico que nunca volverá: ahora programar es algo diferente.

## Convertirse en programador hoy

Convertirse en programador hoy ha perdido completamente el encanto que tenía en los años 80 y 90.

Una vez aprender un lenguaje de programación significaba tener trabajo, hoy solo significa tener una herramienta que te ayuda a resolver parte de un problema.

Un lenguaje de programación ya no es un punto de llegada, sino que representa solo el primer escalón de un camino que no tiene fin.

Este aspecto desalienta a muchos jóvenes a emprender la carrera de programador y también los expone a una serie de desafíos que no existían en el pasado, los pone en un mundo donde cada vez más a menudo uno se siente inadecuado, en un mundo donde se tiene miedo de no estar a la altura.

## La paradoja de la elección y la ansiedad por el rendimiento

Hoy, un aspirante a programador ya no tiene que elegir entre una computadora y un ciclomotor, sino entre docenas de lenguajes, cientos de frameworks e innumerables trayectorias profesionales: frontend, backend, móvil, ciencia de datos, IA, DevOps, y cada día el mercado inventa una sigla nueva donde todos se sienten desprevenidos: DevSecOps, FinOps y así sucesivamente.

Como observa Barry Schwartz en su libro "The Paradox of Choice" (2004), un exceso de opciones puede paradójicamente llevar a la parálisis decisional y la insatisfacción. En el mundo de la programación, este fenómeno es particularmente evidente: según el Stack Overflow Developer Survey, existen más de 80 lenguajes de programación utilizados activamente, con nuevos frameworks emergiendo constantemente.

Esta abundancia ya no es una riqueza, no significa que podamos hacer cualquier cosa, más bien es una manera de hacer que el programador se sienta cada vez más desprevenido: cualquier camino que elija, el riesgo de terminar en un nicho de poco valor es cada vez más probable.

Por eso es conveniente despegarse cada vez más de la parte técnica, especializándose en la actitud hacia la resolución de problemas, que es una práctica que tiene un grado de aprendizaje transversal y debería ayudar a resolver la paradoja de elegir el mejor lenguaje.

Para quienes tenían un tupido flequillo en la frente en los años 80, la pregunta que más se hacía era "¿cómo hago mover este sprite?", luego pasó a "¿qué tecnología me garantizará trabajo por los próximos 5 años?" y ahora comienza a transformarse en "¿cómo puedo mantenerme actual en un mundo en constante evolución?".

Si esto no basta, pensemos en la presión creada por las comunidades online. Si en los años 80 la comparación se limitaba a pocos amigos o a las revistas, hoy plataformas como GitHub, LinkedIn o Twitter exponen constantemente el trabajo de miles de otros desarrolladores, alimentando el síndrome del impostor.

La mayoría de los profesionales de TI experimenta el síndrome del impostor al menos una vez en su carrera, con los programadores particularmente expuestos a este fenómeno debido a la naturaleza colaborativa y pública de su trabajo.

Se tiene la sensación de estar siempre un paso atrás, no se tiene tiempo de leer algo y pensar en probarlo, cuando desde los sótanos de un suburbio de Beijing un equipo de desarrolladores ha creado una herramienta que promete revolucionar el mundo del desarrollo y tú, pobre programador que aún es acosado por sus colegas de trabajo, te sientes cada vez más obsoleto.

## El impacto de la Inteligencia Artificial

Como si no fuera suficiente, el advenimiento de herramientas basadas en IA como GitHub Copilot, ChatGPT, Gemini o Claude están reescribiendo las reglas.
Si por un lado pueden acelerar el desarrollo y ayudar a superar obstáculos, por otro lado corren el riesgo de crear una generación de programadores que sabe "preguntar" pero no "hacer". El riesgo es perder la comprensión profunda de los mecanismos, delegando el pensamiento crítico a la máquina. Se aprende a usar una herramienta, no a resolver un problema desde los fundamentos.

Como se destaca en el informe "State of AI", casi la totalidad de los desarrolladores de Estados Unidos utiliza herramientas de codificación basadas en IA, pero solo una subparte declara comprender plenamente cómo estas herramientas generan sus soluciones.

Si observamos las estadísticas de OpenRouter sobre el uso de IA a lo largo del tiempo, no podemos dejar de notar un aumento vertiginoso en la adopción de estas herramientas, con un crecimiento exponencial de consultas e interacciones.

De hecho, las IA se han convertido en nuestro compañero de trabajo diario, una herramienta imprescindible en la vida de cualquier programador.

Pero cuanto más pasa el tiempo y su evolución, se hace cada vez más evidente que el programador está destinado a perderse en el mar de código que tendrá que revisar, aumentando de manera incontrolada la sensación de inadecuación que tenemos por naturaleza.

A pesar de esto, Bill Gates afirma:

```text
Programming will remain a 100% human profession, even a century from now
```

Una señal de que probablemente podemos dormir tranquilos.

## ¿Qué queda (y qué se necesita) para no perderse?

Sin embargo, a pesar de todo, el corazón de la programación no ha cambiado. No es el lenguaje, no es el framework, no es la IA.

El corazón sigue siendo la **curiosidad**, las ganas de entender, de inventar siempre algo nuevo, sin limitarse a repetir infinitamente lo que hemos aprendido.

Tomemos el ejemplo de BitChat, una aplicación de mensajería descentralizada. Su creación requirió una comprensión profunda de los protocolos de red y la criptografía. La curiosidad de explorar nuevas tecnologías y la determinación de enfrentar nuevos desafíos llevó a su realización: pero ¿cómo se escribió su núcleo? A través de IA, en un fin de semana de vibecoding, pero sin una mente humana detrás del proyecto, ninguna IA (hasta ahora) habría sido capaz de concebirla.

La **lógica** capaz de descomponer un problema en partes diminutas sigue siendo un arte que las IA deben aprender, y es fruto de años de evolución, que estamos tratando de emular día tras día.

Otro aspecto es la **tenacidad** frente a un bug que no se encuentra. Un programador ataca con fuerza bruta, luego reflexiona, estudia y reenfrenta el problema desde nuevos puntos hasta que encuentra una solución aceptable. Actualmente las IA solo tienen una fuerza bruta inmensa que tratan de usar hasta el agotamiento, pero tal vez no sea el mejor enfoque para problemas comprimidos o en los que se necesita una visión holística del producto.

Tal vez, el verdadero desafío para el programador de hoy no es aprender la última tecnología, sino aprender a gestionar el ruido. Aprender a elegir un camino y seguirlo con dedicación, sin dejarse distraer por la frenesí de "lo nuevo a toda costa".

Las nuevas herramientas son una ayuda, no un atajo para no pensar, pero deben ser absorbidas para poder ser explotadas al máximo.

Para convertirse en programadores hoy, se debe primero que todo aprender a ser como ese niño de 1985: concentrado en un objetivo, curioso de descubrir qué hay dentro de la "caja" y listo para leer el manual, aunque hoy ese manual sea tan grande como toda la web.

Y repensando en Bill Gates, esperemos que sus palabras no se conviertan en un meme como la frase:

```text
640K ought to be enough for anybody!
```
