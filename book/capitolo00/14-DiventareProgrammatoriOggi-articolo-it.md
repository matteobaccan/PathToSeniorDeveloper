# Il mondo della programmazione è cambiato e con esso il modo di diventare programmatori

Ricordo ancora il momento in cui decisi di diventare programmatore: era il 1985, le radio suonavano "The Wild Boys" dei Duran Duran e io dovevo fare una scelta importante: "Computer o motorino?".

A 14 anni è una scelta difficile: da un lato potresti realizzare quella che nella tua testa è la naturale evoluzione di un ragazzo a cui piace la matematica, cioè capire cos'è l'informatica e fare ciò che film come War Games dipingevano come qualcosa alla portata di qualsiasi ragazzino; dall'altro, comprare un motorino, sfrecciare libero per le strade, poter andare dove vuoi e mostrarti alle ragazze fuori dallo stereotipo del nerd.

Una scelta difficile, travagliata, pensata per mesi, ma affrontata come tutte le scelte migliori della mia vita: di pancia, in modo assolutamente casuale.

Vinse il computer.

Dopo mesi di attesa, quando riuscii a convincere anche i miei che era una scelta irrinunciabile, trascinai mio padre a comprarlo.

Mio padre conosceva un tale che aveva un "negozio Olivetti", che negli anni '80 significava essere al centro del mondo informatico, e la prima proposta fu un "Olivetti Prodest".

Ero giovane, assolutamente a digiuno di cosa volesse dire programmare, ma di una cosa ero certo: il Prodest era una scelta sbagliata. Tutti avevano il Commodore64, possibile che io dovessi avere un Prodest?

Anche qui, vari giorni per convincere tutti che il Prodest non aveva futuro. "Il Commodore invece sì, era il computer del futuro".

Col senno di poi capisco quanto fosse campata per aria questa affermazione, non avevo nessun dato a supporto, se non le pubblicità martellanti di quel periodo.

Non ricordo il giorno dell'acquisto, ricordo solo la mia gioia nel montarlo: si trattava di collegare za corrente e un monitor, che in realtà era una vecchia TV in bianco e nero.

Il primo giorno ero devastato: in omaggio mi avevano dato un gioco e avevo passato tutta la sera a giocarci.

Pensavo di dormire bene, ma quella notte non riuscii a chiudere occhio, un misto fra gioia, euforia e delusione. A quell'età si hanno sempre più dubbi che certezze: perché avevo perso la sera a giocare, quando invece volevo fare "il programmatore"? In fondo non sapevo neppure cosa volesse dire, ma ero sicuro che non si trattasse di giocare, bensì di qualcosa di diverso.

Nei giorni successivi lessi più volte il manuale: un quaderno ad anelli, in formato A5, con la copertina a righe e il logo Commodore. Credo di ricordare ancora il profumo della carta, ma forse è solo un'illusione della memoria.

Da lì sono iniziati anni di errori, tentativi, presunti successi e fallimenti.

Da linguaggio a linguaggio, da computer a computer, da sistema operativo a sistema operativo, da libreria a libreria, da framework a framework.

Un viaggio durato decenni, dove ogni giorno ho imparato qualcosa di nuovo, dove ogni giorno ho capito che non si smette mai di imparare.

Ma quello è il passato, un romantico passato che non tornerà più: ora programmare è qualcosa di diverso.

## Diventare programmatori oggi

Diventare programmatori oggi ha perso completamente il fascino che aveva negli anni '80 e '90.

Un tempo imparare un linguaggio di programmazione significava avere un lavoro, oggi significa solo avere uno strumento che ti aiuta a risolvere parte di un problema.

Un linguaggio di programmazione non è più un punto d'arrivo, ma rappresenta solo il primo gradino di un percorso che non ha fine.

Questo aspetto scoraggia molti giovani a intraprendere la carriera di programmatore e li espone anche a una serie di sfide che non esistevano in passato, li mette in un mondo dove sempre più spesso ci si sente inadeguati, in un mondo dove si ha paura di non essere all'altezza.

## Il paradosso della scelta e l'ansia da prestazione

Oggi, un aspirante programmatore non deve più scegliere tra un computer e un motorino, ma tra decine di linguaggi, centinaia di framework e innumerevoli percorsi di carriera: frontend, backend, mobile, data science, AI, DevOps, e ogni giorno il mercato inventa una sigla nuova dove ognuno si sente impreparato: DevSecOps, FinOps e chi più ne ha più ne metta.

Come osserva Barry Schwartz nel suo libro "The Paradox of Choice" (2004), l'eccesso di opzioni può paradossalmente portare a paralisi decisionale e insoddisfazione. Nel mondo della programmazione, questo fenomeno è particolarmente evidente: secondo il Stack Overflow Developer Survey, esistono oltre 80 linguaggi di programmazione attivamente utilizzati, con nuovi framework che emergono costantemente.

Questa abbondanza non è più una ricchezza, non vuol dire che possiamo fare qualsiasi cosa, piuttosto è un modo per far sentire il programmatore sempre più impreparato: qualsiasi strada sceglierà, il rischio di finire in una nicchia dallo scarso valore è sempre più probabile.

Per quello è opportuno staccarsi sempre più dalla parte tecnica, specializzandosi sull'attitudine alla risoluzione dei problemi, che è una pratica che ha un grado di apprendimento trasversale e dovrebbe aiutare a risolvere il paradosso della scelta del miglior linguaggio.

Per chi aveva un folto ciuffo sulla fronte negli anni 80, la domanda che più ci si faceva era "come faccio a far muovere questo sprite?", poi è passata a "quale tecnologia mi garantirà un lavoro per i prossimi 5 anni?" ed ora si inizia a trasformare in "come posso rimanere attuale in un mondo in continua evoluzione?".

Se questo non basta, pensiamo alla pressione creata dalle community online. Se negli anni '80 il confronto era limitato a pochi amici o alle riviste, oggi piattaforme come GitHub, LinkedIn o Twitter espongono costantemente il lavoro di migliaia di altri sviluppatori, alimentando la sindrome dell'impostore.

La maggior parte dei professionisti IT sperimenta la sindrome dell'impostore almeno una volta nella propria carriera, con i programmatori particolarmente esposti a questo fenomeno a causa della natura collaborativa e pubblica del loro lavoro.

Si ha la sensazione di essere sempre un passo indietro, non si fa in tempo a leggere qualcosa e a pensare di provarla, che dalle cantine di un sobborgo di Pechino un team di sviluppatori ha creato uno strumento che promette di rivoluzionare il mondo dello sviluppo e tu, povero programmatore che viene ancora bullizzato dai suoi colleghi di lavoro, ti senti sempre più obsoleto.

## L'impatto dell'Intelligenza Artificiale

Come se non bastasse, l'avvento di strumenti basati sull'IA come GitHub Copilot, ChatGPT, Gemini o Claude stanno riscrivendo le regole.
Se da un lato possono accelerare lo sviluppo e aiutare a superare ostacoli, dall'altro rischiano di creare una generazione di programmatori che sa "chiedere" ma non "fare". Il rischio è quello di perdere la comprensione profonda dei meccanismi, delegando il pensiero critico alla macchina. Si impara a usare uno strumento, non a risolvere un problema dalle fondamenta.

Come evidenziato nel report "State of AI", la quasi totalità degli sviluppatori degli Stati Uniti utilizza strumenti di coding basati su IA, ma solo una sottoparte dichiara di comprendere appieno come questi strumenti generano le loro soluzioni.

Se guardiamo le statistiche di OpenRouter sull'utilizzo delle AI nel tempo, non possiamo non notare un aumento vertiginoso dell'adozione di questi strumenti, con una crescita esponenziale delle query e delle interazioni.

Di fatto le AI sono diventate il nostro compagno di lavoro quotidiano, uno strumento imprescindibile nella vita di qualsiasi programmatore.

Ma più passa il tempo e la loro evoluzione, diventa sempre più evidente il fatto che il programmatore è destinato a perdersi nel mare di codice che dovrà andare a controllare, aumentando in modo incontrollato la sensazione di inadeguatezza che abbiamo di natura.

Nonostante questo, Bill Gates afferma:

```text
Programming will remain a 100% human profession, even a century from now
```

Un segno che probabilmente possiamo dormire sonni tranquilli.

## Cosa è rimasto (e cosa serve) per non perdersi?

Eppure, nonostante tutto, il cuore della programmazione non è cambiato. Non è il linguaggio, non è il framework, non è l'IA.

Il cuore è ancora la **curiosità**, la voglia di capire, di inventare sempre qualcosa di nuovo, senza limitarsi a ripetere all'infinito quello che abbiamo appreso.

Facciamo l'esempio di BitChat, un'applicazione di messaggistica decentralizzata. La sua creazione ha richiesto una profonda comprensione dei protocolli di rete e della crittografia. La curiosità di esplorare nuove tecnologie e la determinazione di affrontare nuove sfide ha portato alla sua realizzazione: ma come è stato scritto il suo core? Tramite AI, in un weekend di vibecoding, ma senza una mente umana dietro al progetto, nessuna AI (ad ora) sarebbe stata in grado di pensarla.

La **logica** in grado di scomporre un problema in parti minuscole è ancora un'arte che le AI devono apprendere, ed è frutto di anni di evoluzione, che stiamo tentando di emulare giorno dopo giorno.

Un altro aspetto è la **tenacia** di fronte a un bug che non si trova. Un programmatore attacca a forza bruta, poi riflette, studia e riaffronta il problema da punti nuovi fino a che non trova una soluzione accettabile. Ad ora le AI hanno solo una forza bruta immensa che provano ad utilizzare allo sfinimento, ma forse non è l'approccio migliore per problemi compressi o nei quali è necessaria una visione olistica di prodotto.

Forse, la vera sfida per il programmatore di oggi non è imparare l'ultima tecnologia, ma imparare a gestire il rumore. Imparare a scegliere un percorso e seguirlo con dedizione, senza farsi distrarre dalla frenesia del "nuovo a tutti i costi".

I nuovi strumenti sono un aiuto, non una scorciatoia per non pensare, ma devono essere assorbiti per poter essere sfruttati al massimo.

Per diventare programmatori oggi, bisogna prima di tutto imparare a essere come quel ragazzino del 1985: concentrati su un obiettivo, curiosi di scoprire cosa c'è dentro la "scatola" e pronti a leggere il manuale, anche se oggi quel manuale è grande quanto l'intero web.

E ripensando a Bill Gates, speriamo che le sue parole non diventino un meme come la frase:

```text
640K ought to be enough for anybody!
```
