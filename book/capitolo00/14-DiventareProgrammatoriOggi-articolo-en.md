# The world of programming has changed and with it the way to become a programmer

I still remember the moment I decided to become a programmer: it was 1985, radios were playing "The Wild Boys" by Duran Duran and I had to make an important choice: "Computer or scooter?".

At 14, it's a difficult choice: on one hand you could realize what in your head is the natural evolution of a boy who likes mathematics, that is understanding what computer science is and doing what movies like War Games depicted as something within reach of any kid; on the other hand, buying a scooter, speeding free through the streets, being able to go where you want and showing yourself to girls outside the nerd stereotype.

A difficult choice, agonizing, thought about for months, but faced like all the best choices of my life: instinctively, in a completely random way.

The computer won.

After months of waiting, when I managed to convince my parents too that it was an unmissable choice, I dragged my father to buy it.

My father knew someone who had an "Olivetti store", which in the '80s meant being at the center of the computer world, and the first proposal was an "Olivetti Prodest".

I was young, completely clueless about what programming meant, but I was certain of one thing: the Prodest was the wrong choice. Everyone had the Commodore64, was it possible that I should have a Prodest?

Here too, various days to convince everyone that the Prodest had no future. "The Commodore instead did, it was the computer of the future".

With hindsight I understand how unfounded this statement was, I had no supporting data, except for the hammering advertisements of that period.

I don't remember the day of purchase, I only remember my joy in setting it up: it involved connecting the power and a monitor, which was actually an old black and white TV.

The first day I was devastated: they had given me a game as a gift and I had spent the whole evening playing it.

I thought I would sleep well, but that night I couldn't close my eyes, a mix of joy, euphoria and disappointment. At that age you always have more doubts than certainties: why had I wasted the evening playing, when instead I wanted to be "the programmer"? After all, I didn't even know what it meant, but I was sure it wasn't about playing, but about something different.

In the following days I read the manual several times: a ring binder, in A5 format, with a striped cover and the Commodore logo. I think I still remember the smell of the paper, but maybe it's just an illusion of memory.

From there began years of errors, attempts, presumed successes and failures.

From language to language, from computer to computer, from operating system to operating system, from library to library, from framework to framework.

A journey that lasted decades, where every day I learned something new, where every day I understood that you never stop learning.

But that's the past, a romantic past that will never return: now programming is something different.

## Becoming a programmer today

Becoming a programmer today has completely lost the charm it had in the '80s and '90s.

Once learning a programming language meant having a job, today it only means having a tool that helps you solve part of a problem.

A programming language is no longer a destination, but represents only the first step of a path that has no end.

This aspect discourages many young people from pursuing a programming career and also exposes them to a series of challenges that didn't exist in the past, puts them in a world where more and more often one feels inadequate, in a world where there is fear of not being up to the task.

## The paradox of choice and performance anxiety

Today, an aspiring programmer no longer has to choose between a computer and a scooter, but between dozens of languages, hundreds of frameworks and countless career paths: frontend, backend, mobile, data science, AI, DevOps, and every day the market invents a new acronym where everyone feels unprepared: DevSecOps, FinOps and so on.

As Barry Schwartz observes in his book "The Paradox of Choice" (2004), an excess of options can paradoxically lead to decision paralysis and dissatisfaction. In the programming world, this phenomenon is particularly evident: according to the Stack Overflow Developer Survey, there are over 80 actively used programming languages, with new frameworks constantly emerging.

This abundance is no longer a richness, it doesn't mean we can do anything, rather it's a way to make the programmer feel more and more unprepared: whatever path they choose, the risk of ending up in a niche of little value is increasingly probable.

That's why it's appropriate to increasingly detach from the technical part, specializing in the attitude toward problem solving, which is a practice that has a degree of cross-learning and should help solve the paradox of choosing the best language.

For those who had a thick tuft on their forehead in the '80s, the question most asked was "how do I make this sprite move?", then it became "which technology will guarantee me a job for the next 5 years?" and now it's starting to transform into "how can I stay current in a constantly evolving world?".

If this isn't enough, think about the pressure created by online communities. If in the '80s comparison was limited to a few friends or magazines, today platforms like GitHub, LinkedIn or Twitter constantly expose the work of thousands of other developers, fueling impostor syndrome.

Most IT professionals experience impostor syndrome at least once in their career, with programmers particularly exposed to this phenomenon due to the collaborative and public nature of their work.

You have the feeling of always being one step behind, you don't have time to read something and think about trying it, when from the basements of a Beijing suburb a team of developers has created a tool that promises to revolutionize the world of development and you, poor programmer who is still being bullied by his work colleagues, feel more and more obsolete.

## The impact of Artificial Intelligence

As if that weren't enough, the advent of AI-based tools like GitHub Copilot, ChatGPT, Gemini or Claude are rewriting the rules.
If on one hand they can accelerate development and help overcome obstacles, on the other they risk creating a generation of programmers who know how to "ask" but not "do". The risk is losing deep understanding of mechanisms, delegating critical thinking to the machine. You learn to use a tool, not to solve a problem from the ground up.

As highlighted in the "State of AI" report, almost all developers in the United States use AI-based coding tools, but only a subset claims to fully understand how these tools generate their solutions.

If we look at OpenRouter statistics on AI usage over time, we can't help but notice a dramatic increase in the adoption of these tools, with exponential growth in queries and interactions.

In fact, AIs have become our daily work companion, an essential tool in any programmer's life.

But the more time passes and their evolution, it becomes increasingly evident that the programmer is destined to get lost in the sea of code they will have to check, uncontrollably increasing the sense of inadequacy we have by nature.

Despite this, Bill Gates states:

```text
Programming will remain a 100% human profession, even a century from now
```

A sign that we can probably sleep peacefully.

## What remains (and what's needed) to not get lost?

Yet, despite everything, the heart of programming hasn't changed. It's not the language, it's not the framework, it's not the AI.

The heart is still **curiosity**, the desire to understand, to always invent something new, without limiting ourselves to infinitely repeating what we have learned.

Let's take the example of BitChat, a decentralized messaging application. Its creation required a deep understanding of network protocols and cryptography. The curiosity to explore new technologies and the determination to face new challenges led to its realization: but how was its core written? Through AI, in a weekend of vibecoding, but without a human mind behind the project, no AI (as of now) would have been able to think it up.

**Logic** capable of breaking down a problem into tiny parts is still an art that AIs must learn, and is the result of years of evolution, which we are trying to emulate day after day.

Another aspect is **tenacity** in the face of a bug that can't be found. A programmer attacks with brute force, then reflects, studies and re-approaches the problem from new points until they find an acceptable solution. Currently AIs only have immense brute force that they try to use to exhaustion, but maybe it's not the best approach for compressed problems or those requiring a holistic product vision.

Perhaps, the real challenge for today's programmer is not learning the latest technology, but learning to manage the noise. Learning to choose a path and follow it with dedication, without being distracted by the frenzy of "new at all costs".

New tools are a help, not a shortcut to avoid thinking, but they must be absorbed to be exploited to the maximum.

To become programmers today, you must first learn to be like that kid from 1985: focused on a goal, curious to discover what's inside the "box" and ready to read the manual, even if today that manual is as big as the entire web.

And thinking back to Bill Gates, let's hope his words don't become a meme like the phrase:

```text
640K ought to be enough for anybody!
```
